#pragma version 11
intcblock 1 0 8 32 2 4 6 64 3 7 40 56 60
bytecblock 0x 0x64 0x6372656174696f6e466565416d6f756e74 0x151f7c75 0x746f6b 0x6d61696e7461696e657241646472657373 0x546f6b656e44726f7020666565 0x6c61737444726f704964 0x706572436c61696d466565416d6f756e74 0x746f74616c436c61696d73 0x63 0x6e666452656769737472794964 0x692e6f776e65722e61 0x6c13ede4

// This TEAL was generated by TEALScript v0.106.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
intc 6 // 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *call_UpdateApplication *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(uint64,address)void
*abi_route_createApplication:
	// maintainerAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 0 (maintainerAddress) for createApplication must be a address
	assert

	// nfdRegistryId: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,address)void
	callsub createApplication
	intc 0 // 1
	return

// createApplication(nfdRegistryId: AppID, maintainerAddress: Address): void
createApplication:
	proto 2 0

	// contracts/TokenDrop.algo.ts:88
	// this.nfdRegistryAppId.value = nfdRegistryId
	bytec 11 //  "nfdRegistryId"
	frame_dig -1 // nfdRegistryId: AppID
	app_global_put

	// contracts/TokenDrop.algo.ts:89
	// this.maintainerAddress.value = maintainerAddress
	bytec 5 //  "maintainerAddress"
	frame_dig -2 // maintainerAddress: Address
	app_global_put

	// contracts/TokenDrop.algo.ts:90
	// this.totalClaims.value = 0
	bytec 9 //  "totalClaims"
	intc 1 // 0
	app_global_put

	// contracts/TokenDrop.algo.ts:91
	// this.lastDropId.value = 0
	bytec 7 //  "lastDropId"
	intc 1 // 0
	app_global_put

	// contracts/TokenDrop.algo.ts:92
	// this.creationFeeAmount.value = 10_000_000
	bytec 2 //  "creationFeeAmount"
	pushint 10_000_000
	app_global_put

	// contracts/TokenDrop.algo.ts:93
	// this.perClaimFeeAmount.value = 100_000
	bytec 8 //  "perClaimFeeAmount"
	pushint 100_000
	app_global_put
	retsub

// updateApplication()void
*abi_route_updateApplication:
	// execute updateApplication()void
	callsub updateApplication
	intc 0 // 1
	return

// updateApplication(): void
updateApplication:
	proto 0 0

	// contracts/TokenDrop.algo.ts:98
	// assert(this.txn.sender === this.app.creator, 'Only the creator can update the application')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can update the application
	assert
	retsub

// changeMaintainer(address)void
*abi_route_changeMaintainer:
	// newMaintainer: address
	txna ApplicationArgs 1
	dup
	len
	intc 3 // 32
	==

	// argument 0 (newMaintainer) for changeMaintainer must be a address
	assert

	// execute changeMaintainer(address)void
	callsub changeMaintainer
	intc 0 // 1
	return

// changeMaintainer(newMaintainer: Address): void
//
// Updates the maintainer address of the application.
//
// This method allows the creator of the application to set a new maintainer address for receiving half the creation
// fees
changeMaintainer:
	proto 1 0

	// contracts/TokenDrop.algo.ts:108
	// assert(this.txn.sender === this.app.creator, 'Only the creator can call')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can call
	assert

	// contracts/TokenDrop.algo.ts:109
	// this.maintainerAddress.value = newMaintainer
	bytec 5 //  "maintainerAddress"
	frame_dig -1 // newMaintainer: Address
	app_global_put
	retsub

// changeFees(uint64,uint64)void
*abi_route_changeFees:
	// perClaimFee: uint64
	txna ApplicationArgs 2
	btoi

	// creationFee: uint64
	txna ApplicationArgs 1
	btoi

	// execute changeFees(uint64,uint64)void
	callsub changeFees
	intc 0 // 1
	return

// changeFees(creationFee: uint64, perClaimFee: uint64): void
//
// Updates the creation fee amount required at drop creation (split between maintainer and fee sink)
// This method can only be called by the creator of the application and the fee must be at least 2 ALGO
// 1 ALGO to maintainer address, 1 to fee sink.
// The per-claim fee has to be at least double the per-claim MBR.
// At claim, 50% is sent to the maintainer address, the mbr is subtracted out, and remainder goes to fee sink
changeFees:
	proto 2 0

	// contracts/TokenDrop.algo.ts:120
	// assert(this.txn.sender === this.app.creator, 'Only the creator can call')
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==

	// Only the creator can call
	assert

	// contracts/TokenDrop.algo.ts:121
	// assert(creationFee > 2_000_000, 'fee must be at least 2 algo')
	frame_dig -1 // creationFee: uint64
	pushint 2_000_000
	>

	// fee must be at least 2 algo
	assert

	// contracts/TokenDrop.algo.ts:122
	// assert(creationFee % 2 === 0, 'fee must be even amount')
	frame_dig -1 // creationFee: uint64
	intc 4 // 2
	%
	intc 1 // 0
	==

	// fee must be even amount
	assert

	// contracts/TokenDrop.algo.ts:123
	// assert(perClaimFee >= this.getPerClaimerMbrCost() * 2, 'per-claim fee must >= double mbr cost')
	frame_dig -2 // perClaimFee: uint64
	callsub getPerClaimerMbrCost
	intc 4 // 2
	*
	>=

	// per-claim fee must >= double mbr cost
	assert

	// contracts/TokenDrop.algo.ts:124
	// this.creationFeeAmount.value = creationFee
	bytec 2 //  "creationFeeAmount"
	frame_dig -1 // creationFee: uint64
	app_global_put

	// contracts/TokenDrop.algo.ts:125
	// this.perClaimFeeAmount.value = perClaimFee
	bytec 8 //  "perClaimFeeAmount"
	frame_dig -2 // perClaimFee: uint64
	app_global_put
	retsub

// optinAsset(pay,uint64)void
*abi_route_optinAsset:
	// assetId: uint64
	txna ApplicationArgs 1
	btoi

	// mbrPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 1 (mbrPayment) for optinAsset must be a pay transaction
	assert

	// execute optinAsset(pay,uint64)void
	callsub optinAsset
	intc 0 // 1
	return

// optinAsset(mbrPayment: PayTxn, assetId: AssetID): void
//
// Opts in the application to an asset if not already opted in.
// Verifies the provided payment transaction for sufficient funding to cover
// the minimum balance required for asset opt-in and relevant transaction fees (.102 algo)
// Initiates an asset transfer transaction to complete the opt-in process.
//
// @param {PayTxn} mbrPayment - The payment transaction covering the minimum balance and fees.
// @param {AssetID} assetId - The unique identifier of the asset to opt into.
optinAsset:
	proto 2 0

	// contracts/TokenDrop.algo.ts:138
	// verifyPayTxn(mbrPayment, {
	//             receiver: this.app.address,
	//             amount: globals.assetOptInMinBalance,
	//         })
	// verify receiver
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify amount
	frame_dig -1 // mbrPayment: PayTxn
	gtxns Amount
	global AssetOptInMinBalance
	==

	// transaction verification failed: {"txn":"mbrPayment","field":"amount","expected":"globals.assetOptInMinBalance"}
	assert

	// *if0_condition
	// contracts/TokenDrop.algo.ts:143
	// this.app.address.isOptedInToAsset(assetId)
	global CurrentApplicationAddress
	frame_dig -2 // assetId: AssetID
	asset_holding_get AssetBalance
	swap
	pop
	bz *if0_end

	// *if0_consequent
	// contracts/TokenDrop.algo.ts:144
	// sendPayment({
	//                 receiver: this.txn.sender,
	//                 amount: globals.assetOptInMinBalance,
	//                 note: 'optin refund',
	//             })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:145
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:146
	// amount: globals.assetOptInMinBalance
	global AssetOptInMinBalance
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:147
	// note: 'optin refund'
	pushbytes 0x6f7074696e20726566756e64 // "optin refund"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:149
	// return
	retsub

*if0_end:
	// contracts/TokenDrop.algo.ts:152
	// sendAssetTransfer({
	//             xferAsset: assetId,
	//             assetReceiver: this.app.address,
	//             assetAmount: 0,
	//         })
	itxn_begin
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:153
	// xferAsset: assetId
	frame_dig -2 // assetId: AssetID
	itxn_field XferAsset

	// contracts/TokenDrop.algo.ts:154
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/TokenDrop.algo.ts:155
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// getDropCreateCost()uint64
*abi_route_getDropCreateCost:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// execute getDropCreateCost()uint64
	callsub getDropCreateCost
	itob
	concat
	log
	intc 0 // 1
	return

// getDropCreateCost(): uint64
//
// Calculates the fees required and MBR costs required for box storage for creating a drop with a specified maximum
// number of claimers.  This fee must be sent as a payment to the contract prior to the call to createDrop.
// The actual fee (creationFeeAmount) is split between a maintainer account and the fee sink.  The fee is to help
// prevent 'spam' drops or drops created solely to block drops for specific assets.
//
// @return {uint64} The total MBR required to cover the necessary up-front box storage costs.
getDropCreateCost:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:169
	// feeNeeded: uint64 = this.creationFeeAmount.value
	bytec 2 //  "creationFeeAmount"
	app_global_get
	frame_bury 0 // feeNeeded: uint64

	// contracts/TokenDrop.algo.ts:173
	// feeNeeded += this.costForBoxStorage(1 /* 'd' */ + len<TokenDropId>() + len<TokenDropInfo>())
	frame_dig 0 // feeNeeded: uint64
	pushint 170
	callsub costForBoxStorage
	+
	frame_bury 0 // feeNeeded: uint64

	// contracts/TokenDrop.algo.ts:175
	// feeNeeded += this.costForBoxStorage(3 /* 'tok' */ + len<AssetID>() + len<TokenDropId>())
	frame_dig 0 // feeNeeded: uint64
	pushint 19
	callsub costForBoxStorage
	+
	frame_bury 0 // feeNeeded: uint64

	// contracts/TokenDrop.algo.ts:176
	// return feeNeeded
	frame_dig 0 // feeNeeded: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// getPerClaimerMbrCost()uint64
*abi_route_getPerClaimerMbrCost:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// execute getPerClaimerMbrCost()uint64
	callsub getPerClaimerMbrCost
	itob
	concat
	log
	intc 0 // 1
	return

// getPerClaimerMbrCost(): uint64
//
// Returns the MBR box cost for a single claimer (claimable by anyone later)
getPerClaimerMbrCost:
	proto 0 1

	// contracts/TokenDrop.algo.ts:185
	// return this.costForBoxStorage(1 /* 'c' */ + len<AddressClaimKey>() + len<ClaimedInfo>())
	pushint 73
	callsub costForBoxStorage
	retsub

// getPerClaimerFee()uint64
*abi_route_getPerClaimerFee:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// execute getPerClaimerFee()uint64
	callsub getPerClaimerFee
	itob
	concat
	log
	intc 0 // 1
	return

// getPerClaimerFee(): uint64
//
// Returns the per-claim fee paid (not reclaimable)
getPerClaimerFee:
	proto 0 1

	// contracts/TokenDrop.algo.ts:193
	// return this.perClaimFeeAmount.value
	bytec 8 //  "perClaimFeeAmount"
	app_global_get
	retsub

// getDropInfo(uint64)(uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
*abi_route_getDropInfo:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// tokenDropId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getDropInfo(uint64)(uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	callsub getDropInfo
	concat
	log
	intc 0 // 1
	return

// getDropInfo(tokenDropId: TokenDropId): TokenDropInfo
//
// Retrieves the TokenDropInfo struct for a specific (still active) token drop based on the provided token drop ID.
//
// @param {TokenDropId} tokenDropId - The unique identifier for the token drop.
// @return {TokenDropInfo} An object containing details about the specified token drop.
getDropInfo:
	proto 1 1

	// contracts/TokenDrop.algo.ts:204
	// return this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	retsub

// createDrop(pay,axfer,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))uint64
*abi_route_createDrop:
	// The ABI return prefix
	bytec 3 // 0x151f7c75

	// tokenDropConfig: (uint64,uint64,uint64,uint8,address,uint64[4],uint64)
	txna ApplicationArgs 1
	dup
	len
	pushint 97
	==

	// argument 0 (tokenDropConfig) for createDrop must be a (uint64,uint64,uint64,uint8,address,uint64[4],uint64)
	assert

	// assetTxn: axfer
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 5 //  axfer
	==

	// argument 1 (assetTxn) for createDrop must be a axfer transaction
	assert

	// feeAndMbrPayment: pay
	txn GroupIndex
	intc 4 // 2
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 2 (feeAndMbrPayment) for createDrop must be a pay transaction
	assert

	// execute createDrop(pay,axfer,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))uint64
	callsub createDrop
	itob
	concat
	log
	intc 0 // 1
	return

// createDrop(feeAndMbrPayment: PayTxn, assetTxn: AssetTransferTxn, tokenDropConfig: TokenDropConfig): uint64
//
// Creates a new token drop and registers it in the system.
//
// This method validates and processes a token drop, ensuring all required conditions
// are met. It registers the token drop with an assigned unique DropId, updates the
// relevant state variables, and ensures that the drop complies with gating rules
// and limits.
//
// @param {PayTxn} feeAndMbrPayment - proceeding payment txn into contract account to cover extra mbr needed for box
// storage as well as FUTURE box storage for all possible claims.  ie: 10K tokens, 1K each - 10 possible claims,
// so the cost per claim - the drop creator has to pay that upfront as well.
// @param {AssetTransferTxn} assetTxn - The asset transfer transaction that transfers tokens for this drop.
// @param {TokenDropInfo} tokenDropConfig - The metadata related to the token drop, including drop creator, token details,
// amount per claim, airdrop end time, and related gating info.
// @return {uint64} Returns the token drop id assigned for this drop.
createDrop:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/TokenDrop.algo.ts:224
	// verifyAssetTransferTxn(assetTxn, { assetReceiver: this.app.address })
	// verify assetReceiver
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"assetTxn","field":"assetReceiver","expected":"this.app.address"}
	assert

	// contracts/TokenDrop.algo.ts:225
	// assert(assetTxn.assetAmount > 0, 'must have a positive amount')
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetAmount
	intc 1 // 0
	>

	// must have a positive amount
	assert

	// contracts/TokenDrop.algo.ts:227
	// assert(assetTxn.xferAsset === tokenDropConfig.Token, 'asset sent must be same as asset specified for drops')
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns XferAsset
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 0 8
	btoi
	==

	// asset sent must be same as asset specified for drops
	assert

	// contracts/TokenDrop.algo.ts:228
	// assert(this.app.address.isOptedInToAsset(assetTxn.xferAsset), 'must opt-in contract first')
	global CurrentApplicationAddress
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns XferAsset
	asset_holding_get AssetBalance
	swap
	pop

	// must opt-in contract first
	assert

	// contracts/TokenDrop.algo.ts:230
	// assert(tokenDropConfig.Token === assetTxn.xferAsset, 'token must match asset being transferred')
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 0 8
	btoi
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns XferAsset
	==

	// token must match asset being transferred
	assert

	// contracts/TokenDrop.algo.ts:231
	// assert(
	//             tokenDropConfig.AmountPerClaim <= assetTxn.assetAmount,
	//             'amount per claim must be at least amount transferred',
	//         )
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 8 8
	btoi
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetAmount
	<=

	// amount per claim must be at least amount transferred
	assert

	// contracts/TokenDrop.algo.ts:235
	// assert(
	//             assetTxn.assetAmount % tokenDropConfig.AmountPerClaim === 0,
	//             'amount must be divisible by amount per claim',
	//         )
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 8 8
	btoi
	%
	intc 1 // 0
	==

	// amount must be divisible by amount per claim
	assert

	// contracts/TokenDrop.algo.ts:239
	// assert(
	//             tokenDropConfig.AirdropEndTime > globals.latestTimestamp + 86400,
	//             'airdrop end time must be at least 1 day into the future',
	//         )
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 16 8
	btoi
	global LatestTimestamp
	pushint 86400
	+
	>

	// airdrop end time must be at least 1 day into the future
	assert

	// contracts/TokenDrop.algo.ts:244
	// assert(
	//             tokenDropConfig.AirdropEndTime <= globals.latestTimestamp + 3600 + 86400 * 7,
	//             "airdrop can't last more than 1 week",
	//         )
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 16 8
	btoi
	global LatestTimestamp
	pushint 3600
	+
	pushint 604800
	+
	<=

	// airdrop can't last more than 1 week
	assert

	// *if1_condition
	// contracts/TokenDrop.algo.ts:249
	// this.dropForToken(tokenDropConfig.Token).exists
	bytec 4 //  "tok"
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 0 8
	btoi
	itob
	concat
	box_len
	swap
	pop
	bz *if1_end

	// *if1_consequent
	// contracts/TokenDrop.algo.ts:250
	// dropInfo = this.allDrops(this.dropForToken(tokenDropConfig.Token).value).value
	bytec 1 //  "d"
	bytec 4 //  "tok"
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 0 8
	btoi
	itob
	concat
	box_get

	// box value does not exist: this.dropForToken(tokenDropConfig.Token).value
	assert
	btoi
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// contracts/TokenDrop.algo.ts:251
	// assert(this.isDropExpiredOrEmpty(dropInfo), 'existing drop must be expired or have no remaining tokens')
	frame_dig 0 // storage key//dropInfo
	box_get

	// box value does not exist: this.allDrops(this.dropForToken(tokenDropConfig.Token).value).value
	assert
	callsub isDropExpiredOrEmpty

	// existing drop must be expired or have no remaining tokens
	assert

	// contracts/TokenDrop.algo.ts:253
	// this.cleanupDrop(this.dropForToken(tokenDropConfig.Token).value)
	bytec 4 //  "tok"
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 0 8
	btoi
	itob
	concat
	box_get

	// box value does not exist: this.dropForToken(tokenDropConfig.Token).value
	assert
	btoi
	callsub cleanupDrop

*if1_end:
	// contracts/TokenDrop.algo.ts:255
	// this.checkGatingInfo(tokenDropConfig)
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	callsub checkGatingInfo

	// contracts/TokenDrop.algo.ts:258
	// this.lastDropId.value += 1
	bytec 7 //  "lastDropId"
	app_global_get
	intc 0 // 1
	+
	bytec 7 //  "lastDropId"
	swap
	app_global_put

	// contracts/TokenDrop.algo.ts:259
	// tokenDropId = this.lastDropId.value
	bytec 7 //  "lastDropId"
	app_global_get
	frame_bury 1 // tokenDropId: uint64

	// contracts/TokenDrop.algo.ts:262
	// dropInfo: TokenDropInfo = {
	//             DropId: tokenDropId,
	//             DropCreator: assetTxn.sender,
	//             AmountRemaining: assetTxn.assetAmount,
	//             MaxClaims: assetTxn.assetAmount / tokenDropConfig.AmountPerClaim,
	//             NumClaims: 0,
	//             Config: tokenDropConfig,
	//         }
	frame_dig 1 // tokenDropId: uint64
	itob
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns Sender
	concat
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetAmount
	itob
	concat
	frame_dig -2 // assetTxn: AssetTransferTxn
	gtxns AssetAmount
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	extract 8 8
	btoi
	/
	itob
	concat
	pushbytes 0x0000000000000000
	concat
	frame_dig -3 // tokenDropConfig: TokenDropConfig
	concat
	frame_bury 2 // dropInfo: TokenDropInfo

	// contracts/TokenDrop.algo.ts:272
	// this.addNewDrop(tokenDropId, dropInfo)
	frame_dig 2 // dropInfo: TokenDropInfo
	frame_dig 1 // tokenDropId: uint64
	callsub addNewDrop

	// contracts/TokenDrop.algo.ts:274
	// verifyPayTxn(feeAndMbrPayment, { receiver: this.app.address })
	// verify receiver
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feeAndMbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// contracts/TokenDrop.algo.ts:275
	// mbrCosts = this.getDropCreateCost()
	callsub getDropCreateCost
	frame_bury 3 // mbrCosts: uint64

	// contracts/TokenDrop.algo.ts:276
	// assert(feeAndMbrPayment.amount >= mbrCosts, 'must pay at least MBR costs')
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // mbrCosts: uint64
	>=

	// must pay at least MBR costs
	assert

	// *if2_condition
	// contracts/TokenDrop.algo.ts:277
	// feeAndMbrPayment.amount > mbrCosts
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // mbrCosts: uint64
	>
	bz *if2_end

	// *if2_consequent
	// contracts/TokenDrop.algo.ts:278
	// sendPayment({
	//                 receiver: feeAndMbrPayment.sender,
	//                 amount: feeAndMbrPayment.amount - mbrCosts,
	//                 note: 'excess mbr refund',
	//             })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:279
	// receiver: feeAndMbrPayment.sender
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Sender
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:280
	// amount: feeAndMbrPayment.amount - mbrCosts
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Amount
	frame_dig 3 // mbrCosts: uint64
	-
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:281
	// note: 'excess mbr refund'
	pushbytes 0x657863657373206d627220726566756e64 // "excess mbr refund"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if2_end:
	// contracts/TokenDrop.algo.ts:286
	// sendPayment({
	//             receiver: this.maintainerAddress.value,
	//             amount: this.creationFeeAmount.value / 2,
	//             note: 'TokenDrop fee',
	//         })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:287
	// receiver: this.maintainerAddress.value
	bytec 5 //  "maintainerAddress"
	app_global_get
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:288
	// amount: this.creationFeeAmount.value / 2
	bytec 2 //  "creationFeeAmount"
	app_global_get
	intc 4 // 2
	/
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:289
	// note: 'TokenDrop fee'
	bytec 6 //  "TokenDrop fee"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:291
	// sendPayment({
	//             receiver: blocks[this.txn.firstValid - 1].feeSink,
	//             amount: this.creationFeeAmount.value / 2,
	//             note: 'TokenDrop fee',
	//         })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:292
	// receiver: blocks[this.txn.firstValid - 1].feeSink
	txn FirstValid
	intc 0 // 1
	-
	block BlkFeeSink
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:293
	// amount: this.creationFeeAmount.value / 2
	bytec 2 //  "creationFeeAmount"
	app_global_get
	intc 4 // 2
	/
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:294
	// note: 'TokenDrop fee'
	bytec 6 //  "TokenDrop fee"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:297
	// return tokenDropId
	frame_dig 1 // tokenDropId: uint64

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// cancelDrop(uint64)void
*abi_route_cancelDrop:
	// tokenDropId: uint64
	txna ApplicationArgs 1
	btoi

	// execute cancelDrop(uint64)void
	callsub cancelDrop
	intc 0 // 1
	return

// cancelDrop(tokenDropId: TokenDropId): void
cancelDrop:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:301
	// dropInfo = this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// contracts/TokenDrop.algo.ts:302
	// assert(this.txn.sender === dropInfo.DropCreator, 'only drop creator can cancel a drop')
	txn Sender
	intc 2 //  headOffset
	intc 3 // 32
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	==

	// only drop creator can cancel a drop
	assert

	// contracts/TokenDrop.algo.ts:303
	// this.cleanupDrop(tokenDropId)
	frame_dig -1 // tokenDropId: TokenDropId
	callsub cleanupDrop
	retsub

// claimDrop(pay,uint64,uint64)void
*abi_route_claimDrop:
	// valueToVerify: uint64
	txna ApplicationArgs 2
	btoi

	// tokenDropId: uint64
	txna ApplicationArgs 1
	btoi

	// feeAndMbrPayment: pay
	txn GroupIndex
	intc 0 // 1
	-
	dup
	gtxns TypeEnum
	intc 0 //  pay
	==

	// argument 2 (feeAndMbrPayment) for claimDrop must be a pay transaction
	assert

	// execute claimDrop(pay,uint64,uint64)void
	callsub claimDrop
	intc 0 // 1
	return

// claimDrop(feeAndMbrPayment: PayTxn, tokenDropId: TokenDropId, valueToVerify: uint64): void
//
// Processes a claim request for a specific token drop, ensuring compliance with all validation rules and conditions.
//
// @param {PayTxn} feeAndMbrPayment - The payment transaction object provided by the claimant to cover necessary fees.
// @param {TokenDropId} tokenDropId - The unique identifier of the token drop being claimed.
// @param {uint64} valueToVerify - An optional value used for claim gating verification.
claimDrop:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 5

	// contracts/TokenDrop.algo.ts:314
	// dropInfo = this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -2 // tokenDropId: TokenDropId
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// contracts/TokenDrop.algo.ts:315
	// assert(this.txn.sender !== dropInfo.DropCreator, 'drop creator cannot claim')
	txn Sender
	intc 2 //  headOffset
	intc 3 // 32
	bytec 1 //  "d"
	frame_dig -2 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	!=

	// drop creator cannot claim
	assert

	// contracts/TokenDrop.algo.ts:317
	// assert(!this.isDropExpiredOrEmpty(dropInfo), 'airdrop has ended or out of tokens')
	frame_dig 0 // storage key//dropInfo
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	callsub isDropExpiredOrEmpty
	!

	// airdrop has ended or out of tokens
	assert

	// contracts/TokenDrop.algo.ts:318
	// assert(this.txn.sender.isOptedInToAsset(dropInfo.Config.Token), 'claimant must already be opted-in to token!')
	txn Sender
	intc 7 // 64
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -2 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	asset_holding_get AssetBalance
	swap
	pop

	// claimant must already be opted-in to token!
	assert

	// contracts/TokenDrop.algo.ts:320
	// claimKey = { TokenDropId: tokenDropId, Address: this.txn.sender } as AddressClaimKey
	frame_dig -2 // tokenDropId: TokenDropId
	itob
	txn Sender
	concat
	frame_bury 1 // claimKey: (uint64,address)

	// contracts/TokenDrop.algo.ts:321
	// assert(!this.claimedMap(claimKey).exists, 'already claimed')
	bytec 10 //  "c"
	frame_dig 1 // claimKey: (uint64,address)
	concat
	box_len
	swap
	pop
	!

	// already claimed
	assert

	// contracts/TokenDrop.algo.ts:324
	// this.doesClaimAccountMeetGating(tokenDropId, valueToVerify)
	frame_dig -3 // valueToVerify: uint64
	frame_dig -2 // tokenDropId: TokenDropId
	callsub doesClaimAccountMeetGating

	// contracts/TokenDrop.algo.ts:328
	// perClaimerFee = this.getPerClaimerFee()
	callsub getPerClaimerFee
	frame_bury 2 // perClaimerFee: uint64

	// contracts/TokenDrop.algo.ts:329
	// mbrCost = this.getPerClaimerMbrCost()
	callsub getPerClaimerMbrCost
	frame_bury 3 // mbrCost: uint64

	// contracts/TokenDrop.algo.ts:330
	// assert(perClaimerFee >= mbrCost * 2, 'per-claim fee too low')
	frame_dig 2 // perClaimerFee: uint64
	frame_dig 3 // mbrCost: uint64
	intc 4 // 2
	*
	>=

	// per-claim fee too low
	assert

	// contracts/TokenDrop.algo.ts:331
	// verifyPayTxn(feeAndMbrPayment, {
	//             receiver: this.app.address,
	//             sender: this.txn.sender,
	//             amount: perClaimerFee,
	//         })
	// verify receiver
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==

	// transaction verification failed: {"txn":"feeAndMbrPayment","field":"receiver","expected":"this.app.address"}
	assert

	// verify sender
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Sender
	txn Sender
	==

	// transaction verification failed: {"txn":"feeAndMbrPayment","field":"sender","expected":"this.txn.sender"}
	assert

	// verify amount
	frame_dig -1 // feeAndMbrPayment: PayTxn
	gtxns Amount
	frame_dig 2 // perClaimerFee: uint64
	==

	// transaction verification failed: {"txn":"feeAndMbrPayment","field":"amount","expected":"perClaimerFee"}
	assert

	// contracts/TokenDrop.algo.ts:336
	// maintainerPortion = (perClaimerFee * 500) / 1000
	frame_dig 2 // perClaimerFee: uint64
	pushint 500
	*
	pushint 1000
	/
	frame_bury 4 // maintainerPortion: uint64

	// contracts/TokenDrop.algo.ts:337
	// sendPayment({
	//             receiver: this.maintainerAddress.value,
	//             amount: maintainerPortion,
	//             note: 'TokenDrop fee',
	//         })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:338
	// receiver: this.maintainerAddress.value
	bytec 5 //  "maintainerAddress"
	app_global_get
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:339
	// amount: maintainerPortion
	frame_dig 4 // maintainerPortion: uint64
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:340
	// note: 'TokenDrop fee'
	bytec 6 //  "TokenDrop fee"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:343
	// feeSinkPortion = perClaimerFee - maintainerPortion - mbrCost
	frame_dig 2 // perClaimerFee: uint64
	frame_dig 4 // maintainerPortion: uint64
	-
	frame_dig 3 // mbrCost: uint64
	-
	frame_bury 5 // feeSinkPortion: uint64

	// contracts/TokenDrop.algo.ts:344
	// sendPayment({
	//             receiver: blocks[this.txn.firstValid - 1].feeSink,
	//             amount: feeSinkPortion,
	//             note: 'TokenDrop fee',
	//         })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:345
	// receiver: blocks[this.txn.firstValid - 1].feeSink
	txn FirstValid
	intc 0 // 1
	-
	block BlkFeeSink
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:346
	// amount: feeSinkPortion
	frame_dig 5 // feeSinkPortion: uint64
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:347
	// note: 'TokenDrop fee'
	bytec 6 //  "TokenDrop fee"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:352
	// this.claimedMap(claimKey).value = { TxnId: this.txn.txID as bytes32 }
	bytec 10 //  "c"
	frame_dig 1 // claimKey: (uint64,address)
	concat
	txn TxID
	pushbytes 0x0000000000000000000000000000000000000000000000000000000000000000
	concat
	dup
	extract 32 0
	bytec 0 // 0x
	b==
	assert
	extract 0 32
	box_put

	// contracts/TokenDrop.algo.ts:354
	// this.totalClaims.value += 1
	bytec 9 //  "totalClaims"
	app_global_get
	intc 0 // 1
	+
	bytec 9 //  "totalClaims"
	swap
	app_global_put

	// contracts/TokenDrop.algo.ts:356
	// this.sendTokensFromDrop(dropInfo, this.txn.sender, dropInfo.Config.AmountPerClaim)
	pushint 72
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -2 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	txn Sender
	frame_dig 0 // storage key//dropInfo
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	callsub sendTokensFromDrop
	retsub

// claimClaimerBoxCost(uint64,address,address)void
*abi_route_claimClaimerBoxCost:
	// receiver: address
	txna ApplicationArgs 3
	dup
	len
	intc 3 // 32
	==

	// argument 0 (receiver) for claimClaimerBoxCost must be a address
	assert

	// claimerAddress: address
	txna ApplicationArgs 2
	dup
	len
	intc 3 // 32
	==

	// argument 1 (claimerAddress) for claimClaimerBoxCost must be a address
	assert

	// tokenDropId: uint64
	txna ApplicationArgs 1
	btoi

	// execute claimClaimerBoxCost(uint64,address,address)void
	callsub claimClaimerBoxCost
	intc 0 // 1
	return

// claimClaimerBoxCost(tokenDropId: TokenDropId, claimerAddress: Address, receiver: Address): void
claimClaimerBoxCost:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 3

	// contracts/TokenDrop.algo.ts:364
	// dropInfo = this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// contracts/TokenDrop.algo.ts:365
	// assert(this.isDropExpiredOrEmpty(dropInfo), 'drop MUST be expired or empty!')
	frame_dig 0 // storage key//dropInfo
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	callsub isDropExpiredOrEmpty

	// drop MUST be expired or empty!
	assert

	// contracts/TokenDrop.algo.ts:367
	// preMbr = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 1 // preMbr: uint64

	// contracts/TokenDrop.algo.ts:368
	// claimKey = { TokenDropId: tokenDropId, Address: claimerAddress } as AddressClaimKey
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	frame_dig -2 // claimerAddress: Address
	concat
	frame_bury 2 // claimKey: (uint64,address)

	// contracts/TokenDrop.algo.ts:369
	// this.claimedMap(claimKey).delete()
	bytec 10 //  "c"
	frame_dig 2 // claimKey: (uint64,address)
	concat
	box_del

	// contracts/TokenDrop.algo.ts:370
	// mbrRefund = preMbr - this.app.address.minBalance
	frame_dig 1 // preMbr: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	frame_bury 3 // mbrRefund: uint64

	// contracts/TokenDrop.algo.ts:371
	// sendPayment({ receiver: receiver, amount: mbrRefund })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:371
	// receiver: receiver
	frame_dig -3 // receiver: Address
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:371
	// amount: mbrRefund
	frame_dig 3 // mbrRefund: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// cleanupDrop(uint64)void
*abi_route_cleanupDrop:
	// tokenDropId: uint64
	txna ApplicationArgs 1
	btoi

	// execute cleanupDrop(uint64)void
	callsub cleanupDrop
	intc 0 // 1
	return

// cleanupDrop(tokenDropId: TokenDropId): void
//
// Cleans up an expired token drop by performing necessary actions such as refunding remaining tokens
// to the drop creator and removing the drop from the active drops.
// Called if a new drop is created for the same asset id, and by anyone (presumably creator) if a drop is expired/empty.
// Also called if the creator cancels the drop early.
//
// @param {TokenDropId} tokenDropId - The identifier of the token drop to be cleaned up.
// @return {void} This method does not return a value.
cleanupDrop:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/TokenDrop.algo.ts:385
	// dropInfo = clone(this.allDrops(tokenDropId).value)
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	frame_bury 0 // dropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))

	// *if3_condition
	// contracts/TokenDrop.algo.ts:386
	// this.txn.sender !== dropInfo.DropCreator
	txn Sender
	frame_dig 0 // dropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 8 32
	!=
	bz *if3_end

	// *if3_consequent
	// contracts/TokenDrop.algo.ts:389
	// assert(this.isDropExpiredOrEmpty(dropInfo), 'drop MUST be expired or empty')
	frame_dig 0 // dropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	callsub isDropExpiredOrEmpty

	// drop MUST be expired or empty
	assert

*if3_end:
	// contracts/TokenDrop.algo.ts:392
	// preMbr = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 1 // preMbr: uint64

	// contracts/TokenDrop.algo.ts:393
	// this.refundDropCreatorRemainingTokens(tokenDropId)
	frame_dig -1 // tokenDropId: TokenDropId
	callsub refundDropCreatorRemainingTokens

	// contracts/TokenDrop.algo.ts:394
	// this.removeFromDrops(tokenDropId)
	frame_dig -1 // tokenDropId: TokenDropId
	callsub removeFromDrops

	// contracts/TokenDrop.algo.ts:396
	// mbrRefund = preMbr - this.app.address.minBalance
	frame_dig 1 // preMbr: uint64
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	-
	frame_bury 2 // mbrRefund: uint64

	// contracts/TokenDrop.algo.ts:397
	// sendPayment({ receiver: dropInfo.DropCreator, amount: mbrRefund, note: 'refund from removing token drop' })
	itxn_begin
	intc 0 //  pay
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:397
	// receiver: dropInfo.DropCreator
	frame_dig 0 // dropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 8 32
	itxn_field Receiver

	// contracts/TokenDrop.algo.ts:397
	// amount: mbrRefund
	frame_dig 2 // mbrRefund: uint64
	itxn_field Amount

	// contracts/TokenDrop.algo.ts:397
	// note: 'refund from removing token drop'
	pushbytes 0x726566756e642066726f6d2072656d6f76696e6720746f6b656e2064726f70 // "refund from removing token drop"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// addNewDrop(tokenDropId: TokenDropId, dropInfo: TokenDropInfo): void
//
// Adds a new token drop by associating the given drop information with the drop ID and asset ID.
//
// @param {TokenDropId} tokenDropId - The unique identifier for the token drop.
// @param {TokenDropInfo} dropInfo - The information about the token drop to be added.
// @return {void} This method does not return anything.
addNewDrop:
	proto 2 0

	// contracts/TokenDrop.algo.ts:408
	// this.allDrops(tokenDropId).value = dropInfo
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	frame_dig -2 // dropInfo: TokenDropInfo
	box_put

	// contracts/TokenDrop.algo.ts:409
	// this.dropForToken(dropInfo.Config.Token).value = tokenDropId
	bytec 4 //  "tok"
	frame_dig -2 // dropInfo: TokenDropInfo
	extract 64 8
	btoi
	itob
	concat
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	box_put
	retsub

// removeFromDrops(tokenDropId: TokenDropId): void
removeFromDrops:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:413
	// dropInfo = this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// contracts/TokenDrop.algo.ts:414
	// this.dropForToken(dropInfo.Config.Token).delete()
	bytec 4 //  "tok"
	intc 7 // 64
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	itob
	concat
	box_del

	// contracts/TokenDrop.algo.ts:417
	// this.allDrops(tokenDropId).delete()
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	box_del
	retsub

// refundDropCreatorRemainingTokens(tokenDropId: TokenDropId): void
//
// This function refunds the remaining tokens created in a specific token drop.
// The amount of tokens to be refunded is determined by checking the 'AmountRemaining' property
// of the corresponding TokenDrop object. If this value is greater than zero, the function will call
// the `sendTokensFromDrop` method with appropriate parameters to transfer these remaining tokens back
// to the creator of the token drop (identified by 'DropCreator' in the TokenDrop object). The updated
// AmountRemaining is then checked to ensure that it has been removed from the active drops. If this fails,
// an assertion error will be thrown indicating that the drop should have been removed.
// @param tokenDropId - The ID of the TokenDrop for which tokens are being refunded.
refundDropCreatorRemainingTokens:
	proto 1 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:431
	// dropInfo = this.allDrops(tokenDropId).value
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	frame_bury 0 // storage key//dropInfo

	// *if4_condition
	// contracts/TokenDrop.algo.ts:432
	// dropInfo.AmountRemaining > 0
	intc 10 //  headOffset
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 1 // 0
	>
	bz *if4_end

	// *if4_consequent
	// contracts/TokenDrop.algo.ts:435
	// this.sendTokensFromDrop(dropInfo, dropInfo.DropCreator, dropInfo.AmountRemaining)
	intc 10 //  headOffset
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 2 //  headOffset
	intc 3 // 32
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	frame_dig 0 // storage key//dropInfo
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	callsub sendTokensFromDrop

*if4_end:
	// *if5_condition
	// contracts/TokenDrop.algo.ts:437
	// this.app.address.assetBalance(dropInfo.Config.Token) === 0
	global CurrentApplicationAddress
	intc 7 // 64
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	asset_holding_get AssetBalance
	pop
	intc 1 // 0
	==
	bz *if5_end

	// *if5_consequent
	// contracts/TokenDrop.algo.ts:439
	// sendAssetTransfer({
	//                 xferAsset: dropInfo.Config.Token,
	//                 assetReceiver: this.app.address,
	//                 assetCloseTo: this.app.address,
	//                 assetAmount: 0,
	//                 note: 'opt-out of token',
	//             })
	itxn_begin
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:440
	// xferAsset: dropInfo.Config.Token
	intc 7 // 64
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	itxn_field XferAsset

	// contracts/TokenDrop.algo.ts:441
	// assetReceiver: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetReceiver

	// contracts/TokenDrop.algo.ts:442
	// assetCloseTo: this.app.address
	global CurrentApplicationAddress
	itxn_field AssetCloseTo

	// contracts/TokenDrop.algo.ts:443
	// assetAmount: 0
	intc 1 // 0
	itxn_field AssetAmount

	// contracts/TokenDrop.algo.ts:444
	// note: 'opt-out of token'
	pushbytes 0x6f70742d6f7574206f6620746f6b656e // "opt-out of token"
	itxn_field Note

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

*if5_end:
	retsub

// sendTokensFromDrop(dropInfo: TokenDropInfo, receiver: Address, amountToSend: uint64): uint64
//
// Sends a specified amount of tokens from a token drop to the given receiver
// and updates the remaining balance of the drop. If the drop is fully claimed,
// it is removed from the active drops.
//
// @param {TokenDropInfo} dropInfo - Information about the token drop, including the token type and remaining balance.
// @param {Address} receiver - The address of the recipient who will receive the tokens.
// @param {uint64} amountToSend - The amount of tokens to send to the receiver.
// @return {uint64} The remaining balance of tokens in the token drop after the transfer.
sendTokensFromDrop:
	proto 3 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:460
	// sendAssetTransfer({
	//             xferAsset: dropInfo.Config.Token,
	//             assetReceiver: receiver,
	//             assetAmount: amountToSend,
	//         })
	itxn_begin
	intc 5 //  axfer
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:461
	// xferAsset: dropInfo.Config.Token
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 64 8
	btoi
	itxn_field XferAsset

	// contracts/TokenDrop.algo.ts:462
	// assetReceiver: receiver
	frame_dig -2 // receiver: Address
	itxn_field AssetReceiver

	// contracts/TokenDrop.algo.ts:463
	// assetAmount: amountToSend
	frame_dig -3 // amountToSend: uint64
	itxn_field AssetAmount

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:467
	// remaining = dropInfo.AmountRemaining - amountToSend
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 40 8
	btoi
	frame_dig -3 // amountToSend: uint64
	-
	frame_bury 0 // remaining: uint64

	// contracts/TokenDrop.algo.ts:468
	// this.allDrops(dropInfo.DropId).value.AmountRemaining = remaining
	intc 10 //  headOffset
	frame_dig 0 // remaining: uint64
	itob
	bytec 1 //  "d"
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/TokenDrop.algo.ts:469
	// this.allDrops(dropInfo.DropId).value.NumClaims += 1
	intc 11 //  headOffset
	dup
	intc 2 // 8
	bytec 1 //  "d"
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_extract
	btoi
	intc 0 // 1
	+
	itob
	bytec 1 //  "d"
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 0 8
	btoi
	itob
	concat
	cover 2
	box_replace

	// contracts/TokenDrop.algo.ts:471
	// return remaining
	frame_dig 0 // remaining: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// isDropExpiredOrEmpty(dropInfo: TokenDropInfo): boolean
//
// Checks if the drop is either expired or empty (all tokens distributed) based on the current timestamp.
//
// @param {TokenDropInfo} dropInfo - The information about the token drop, including configuration details like the airdrop end time.
// @return {boolean} Returns true if the airdrop is expired based on the latest timestamp or if it is considered empty; otherwise, false.
isDropExpiredOrEmpty:
	proto 1 1

	// contracts/TokenDrop.algo.ts:481
	// return dropInfo.AmountRemaining === 0 || globals.latestTimestamp > dropInfo.Config.AirdropEndTime
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 40 8
	btoi
	intc 1 // 0
	==
	dup
	bnz *skip_or0
	global LatestTimestamp
	frame_dig -1 // dropInfo: TokenDropInfo
	extract 80 8
	btoi
	>
	||

*skip_or0:
	retsub

// doesClaimAccountMeetGating(tokenDropId: TokenDropId, valueToVerify: uint64): void
//
// Checks if an account wanting to claim tokens meets the gating requirements specified by the airdrop creator.
//
// @param {TokenDropId} tokenDropId - The id of the validator.
// @param {uint64} valueToVerify - The value to verify against the gating requirements.
// @returns {void} or asserts if requirements not met.
doesClaimAccountMeetGating:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 11

	// contracts/TokenDrop.algo.ts:492
	// type = this.allDrops(tokenDropId).value.Config.entryGatingType
	pushint 88
	intc 0 // 1
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	cover 2
	box_extract
	btoi
	frame_bury 0 // type: uint8

	// *if6_condition
	// contracts/TokenDrop.algo.ts:493
	// type === GATING_TYPE_NONE
	frame_dig 0 // type: uint8
	intc 1 // 0
	==
	bz *if6_end

	// *if6_consequent
	// contracts/TokenDrop.algo.ts:494
	// return
	retsub

*if6_end:
	// contracts/TokenDrop.algo.ts:496
	// claimer = this.txn.sender
	txn Sender
	frame_bury 1 // claimer: address

	// contracts/TokenDrop.algo.ts:497
	// tokenDropInfo = clone(this.allDrops(tokenDropId).value)
	bytec 1 //  "d"
	frame_dig -1 // tokenDropId: TokenDropId
	itob
	concat
	box_get

	// box value does not exist: this.allDrops(tokenDropId).value
	assert
	frame_bury 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))

	// *if7_condition
	// contracts/TokenDrop.algo.ts:501
	// type === GATING_TYPE_ASSETS_CREATED_BY ||
	//             type === GATING_TYPE_ASSET_ID ||
	//             type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 0 // 1
	==
	dup
	bnz *skip_or1
	frame_dig 0 // type: uint8
	intc 4 // 2
	==
	||

*skip_or1:
	dup
	bnz *skip_or2
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	||

*skip_or2:
	bz *if7_end

	// *if7_consequent
	// contracts/TokenDrop.algo.ts:505
	// assert(valueToVerify !== 0)
	frame_dig -2 // valueToVerify: uint64
	intc 1 // 0
	!=
	assert

	// contracts/TokenDrop.algo.ts:506
	// balRequired = tokenDropInfo.Config.gatingAssetMinBalance
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 153 8
	btoi
	frame_bury 3 // balRequired: uint64

	// *if8_condition
	// contracts/TokenDrop.algo.ts:507
	// balRequired === 0
	frame_dig 3 // balRequired: uint64
	intc 1 // 0
	==
	bz *if8_end

	// *if8_consequent
	// contracts/TokenDrop.algo.ts:508
	// balRequired = 1
	intc 0 // 1
	frame_bury 3 // balRequired: uint64

*if8_end:
	// contracts/TokenDrop.algo.ts:510
	// assert(
	//                 claimer.assetBalance(AssetID.fromUint64(valueToVerify)) >= balRequired,
	//                 'must have required minimum balance of validator defined token to add stake',
	//             )
	frame_dig 1 // claimer: address
	frame_dig -2 // valueToVerify: uint64
	asset_holding_get AssetBalance
	pop
	frame_dig 3 // balRequired: uint64
	>=

	// must have required minimum balance of validator defined token to add stake
	assert

*if7_end:
	// *if9_condition
	// contracts/TokenDrop.algo.ts:515
	// type === GATING_TYPE_ASSETS_CREATED_BY
	frame_dig 0 // type: uint8
	intc 0 // 1
	==
	bz *if9_end

	// *if9_consequent
	// contracts/TokenDrop.algo.ts:516
	// assert(
	//                 AssetID.fromUint64(valueToVerify).creator === tokenDropInfo.Config.entryGatingAddress,
	//                 'specified asset must be created by creator that the validator defined as a requirement to stake',
	//             )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 89 32
	==

	// specified asset must be created by creator that the validator defined as a requirement to stake
	assert

*if9_end:
	// *if10_condition
	// contracts/TokenDrop.algo.ts:521
	// type === GATING_TYPE_ASSET_ID
	frame_dig 0 // type: uint8
	intc 4 // 2
	==
	bz *if10_end

	// *if10_consequent
	// contracts/TokenDrop.algo.ts:522
	// found = false
	intc 1 // 0
	frame_bury 4 // found: bool

	// contracts/TokenDrop.algo.ts:523
	// tokenDropInfo.Config.entryGatingAssets
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 121 32
	dup
	frame_bury 5 // copy of the array we are iterating over
	extract 0 8
	btoi
	frame_bury 6 // assetId: uint64
	intc 1 // 0
	frame_bury 7 // the offset we are extracting the next element from

*forOf_0:
	// *if11_condition
	// contracts/TokenDrop.algo.ts:524
	// valueToVerify === assetId
	frame_dig -2 // valueToVerify: uint64
	frame_dig 6 // assetId: uint64
	==
	bz *if11_end

	// *if11_consequent
	// contracts/TokenDrop.algo.ts:525
	// found = true
	intc 0 // 1
	frame_bury 4 // found: bool
	b *forOf_0_end

*if11_end:

*forOf_0_continue:
	// increment offset and loop if not out of bounds
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	+
	dup
	intc 3 //  offset of last element
	<
	bz *forOf_0_end
	frame_bury 7 // the offset we are extracting the next element from
	frame_dig 5 // copy of the array we are iterating over
	frame_dig 7 // the offset we are extracting the next element from
	intc 2 // 8
	extract
	btoi
	frame_bury 6 // assetId: uint64
	b *forOf_0

*forOf_0_end:
	// contracts/TokenDrop.algo.ts:529
	// assert(found, 'specified asset must be identical to the asset id defined as a requirement to stake')
	frame_dig 4 // found: bool

	// specified asset must be identical to the asset id defined as a requirement to stake
	assert

*if10_end:
	// *if12_condition
	// contracts/TokenDrop.algo.ts:531
	// type === GATING_TYPE_CREATED_BY_NFD_ADDRESSES
	frame_dig 0 // type: uint8
	intc 8 // 3
	==
	bz *if12_end

	// *if12_consequent
	// contracts/TokenDrop.algo.ts:534
	// assert(
	//                 this.isAddressInNFDCAAlgoList(
	//                     tokenDropInfo.Config.entryGatingAssets[0],
	//                     AssetID.fromUint64(valueToVerify).creator,
	//                 ),
	//                 'specified asset must be created by creator that is one of the linked addresses in an nfd',
	//             )
	frame_dig -2 // valueToVerify: uint64
	asset_params_get AssetCreator
	pop
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 121 8
	btoi
	callsub isAddressInNFDCAAlgoList

	// specified asset must be created by creator that is one of the linked addresses in an nfd
	assert

*if12_end:
	// *if13_condition
	// contracts/TokenDrop.algo.ts:542
	// type === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig 0 // type: uint8
	intc 5 // 4
	==
	bz *if13_end

	// *if13_consequent
	// contracts/TokenDrop.algo.ts:544
	// userOfferedNFDAppId = valueToVerify
	frame_dig -2 // valueToVerify: uint64
	frame_bury 8 // userOfferedNFDAppId: uint64

	// contracts/TokenDrop.algo.ts:545
	// assert(this.isNfdAppIdValid(userOfferedNFDAppId), 'provided NFD must be valid')
	frame_dig 8 // userOfferedNFDAppId: uint64
	callsub isNfdAppIdValid

	// provided NFD must be valid
	assert

	// contracts/TokenDrop.algo.ts:548
	// assert(
	//                 rawBytes(AppID.fromUint64(userOfferedNFDAppId).globalState('i.owner.a') as Address) ===
	//                     rawBytes(claimer) || this.isAddressInNFDCAAlgoList(userOfferedNFDAppId, claimer),
	//                 "provided nfd for entry isn't owned or linked to the claimer",
	//             )
	frame_dig 8 // userOfferedNFDAppId: uint64
	bytec 12 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppId).globalState('i.owner.a')
	assert
	frame_dig 1 // claimer: address
	==
	dup
	bnz *skip_or3
	frame_dig 1 // claimer: address
	frame_dig 8 // userOfferedNFDAppId: uint64
	callsub isAddressInNFDCAAlgoList
	||

*skip_or3:
	// provided nfd for entry isn't owned or linked to the claimer
	assert

	// contracts/TokenDrop.algo.ts:555
	// assert(
	//                 btoi(AppID.fromUint64(userOfferedNFDAppId).globalState('i.parentAppID') as bytes) ===
	//                     tokenDropInfo.Config.entryGatingAssets[0],
	//                 'specified nfd must be a segment of the nfd the validator specified as a requirement',
	//             )
	frame_dig 8 // userOfferedNFDAppId: uint64
	pushbytes 0x692e706172656e744170704944 // "i.parentAppID"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppId).globalState('i.parentAppID')
	assert
	btoi
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 121 8
	btoi
	==

	// specified nfd must be a segment of the nfd the validator specified as a requirement
	assert

*if13_end:
	// *if14_condition
	// contracts/TokenDrop.algo.ts:561
	// type === GATING_TYPE_NFD_W_VERIFIED_TWITTER
	frame_dig 0 // type: uint8
	pushint 5
	==
	bz *if14_end

	// *if14_consequent
	// contracts/TokenDrop.algo.ts:562
	// this.checkValidV3NfdAndOwnedByClaimer(valueToVerify, claimer)
	frame_dig 1 // claimer: address
	frame_dig -2 // valueToVerify: uint64
	callsub checkValidV3NfdAndOwnedByClaimer

	// contracts/TokenDrop.algo.ts:563
	// twitterVal = sendMethodCall<[bytes], bytes>({
	//                 applicationID: AppID.fromUint64(valueToVerify),
	//                 name: 'readField',
	//                 methodArgs: ['v.twitter'],
	//             })
	itxn_begin
	intc 6 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "readField(byte[])byte[]"
	itxn_field ApplicationArgs

	// contracts/TokenDrop.algo.ts:564
	// applicationID: AppID.fromUint64(valueToVerify)
	frame_dig -2 // valueToVerify: uint64
	itxn_field ApplicationID

	// contracts/TokenDrop.algo.ts:566
	// methodArgs: ['v.twitter']
	pushbytes 0x0009762e74776974746572
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 0 // 1
	-
	itxnas Logs
	extract 4 0
	extract 2 0
	frame_bury 9 // twitterVal: byte[]

	// contracts/TokenDrop.algo.ts:568
	// assert(twitterVal !== '', 'must have verified twitter')
	frame_dig 9 // twitterVal: byte[]
	bytec 0 //  ""
	!=

	// must have verified twitter
	assert

*if14_end:
	// *if15_condition
	// contracts/TokenDrop.algo.ts:570
	// type === GATING_TYPE_NFD_W_VERIFIED_BLUESKY
	frame_dig 0 // type: uint8
	intc 6 // 6
	==
	bz *if15_end

	// *if15_consequent
	// contracts/TokenDrop.algo.ts:571
	// this.checkValidV3NfdAndOwnedByClaimer(valueToVerify, claimer)
	frame_dig 1 // claimer: address
	frame_dig -2 // valueToVerify: uint64
	callsub checkValidV3NfdAndOwnedByClaimer

	// contracts/TokenDrop.algo.ts:572
	// twitterVal = sendMethodCall<[bytes], bytes>({
	//                 applicationID: AppID.fromUint64(valueToVerify),
	//                 name: 'readField',
	//                 methodArgs: ['v.blueskydid'],
	//             })
	itxn_begin
	intc 6 //  appl
	itxn_field TypeEnum
	bytec 13 //  method "readField(byte[])byte[]"
	itxn_field ApplicationArgs

	// contracts/TokenDrop.algo.ts:573
	// applicationID: AppID.fromUint64(valueToVerify)
	frame_dig -2 // valueToVerify: uint64
	itxn_field ApplicationID

	// contracts/TokenDrop.algo.ts:575
	// methodArgs: ['v.blueskydid']
	pushbytes 0x000c762e626c7565736b79646964
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 0 // 1
	-
	itxnas Logs
	extract 4 0
	extract 2 0
	frame_bury 10 // twitterVal: byte[]

	// contracts/TokenDrop.algo.ts:577
	// assert(twitterVal !== '', 'must have verified bluesky')
	frame_dig 10 // twitterVal: byte[]
	bytec 0 //  ""
	!=

	// must have verified bluesky
	assert

*if15_end:
	// *if16_condition
	// contracts/TokenDrop.algo.ts:579
	// type === GATING_TYPE_NFD_HOLDING_AGE
	frame_dig 0 // type: uint8
	intc 9 // 7
	==
	bz *if16_end

	// *if16_consequent
	// contracts/TokenDrop.algo.ts:580
	// this.checkValidV3NfdAndOwnedByClaimer(valueToVerify, claimer)
	frame_dig 1 // claimer: address
	frame_dig -2 // valueToVerify: uint64
	callsub checkValidV3NfdAndOwnedByClaimer

	// contracts/TokenDrop.algo.ts:581
	// timePurchased = btoi(AppID.fromUint64(valueToVerify).globalState('i.timePurchased') as bytes)
	frame_dig -2 // valueToVerify: uint64
	pushbytes 0x692e74696d65507572636861736564 // "i.timePurchased"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(valueToVerify).globalState('i.timePurchased')
	assert
	btoi
	frame_bury 11 // timePurchased: uint64

	// contracts/TokenDrop.algo.ts:582
	// assert(
	//                 timePurchased + tokenDropInfo.Config.gatingAssetMinBalance * 24 * 60 * 60 <= globals.latestTimestamp,
	//                 'nfd must be held for min num of days',
	//             )
	frame_dig 11 // timePurchased: uint64
	frame_dig 2 // tokenDropInfo: (uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))
	extract 153 8
	btoi
	pushint 24
	*
	intc 12 // 60
	*
	intc 12 // 60
	*
	+
	global LatestTimestamp
	<=

	// nfd must be held for min num of days
	assert

*if16_end:
	retsub

// checkValidV3NfdAndOwnedByClaimer(valueToVerify: uint64, claimer: Address): void
checkValidV3NfdAndOwnedByClaimer:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:591
	// userOfferedNFDAppId = valueToVerify
	frame_dig -1 // valueToVerify: uint64
	frame_bury 0 // userOfferedNFDAppId: uint64

	// contracts/TokenDrop.algo.ts:592
	// assert(this.isNfdAppIdValid(userOfferedNFDAppId), 'provided NFD must be valid')
	frame_dig 0 // userOfferedNFDAppId: uint64
	callsub isNfdAppIdValid

	// provided NFD must be valid
	assert

	// contracts/TokenDrop.algo.ts:594
	// assert(!this.isNfdPreV3(userOfferedNFDAppId), 'NFD must be V3 or later')
	frame_dig 0 // userOfferedNFDAppId: uint64
	callsub isNfdPreV3
	!

	// NFD must be V3 or later
	assert

	// contracts/TokenDrop.algo.ts:596
	// assert(!this.isNfdForSale(userOfferedNFDAppId), 'NFD must not be for sale')
	frame_dig 0 // userOfferedNFDAppId: uint64
	callsub isNfdForSale
	!

	// NFD must not be for sale
	assert

	// contracts/TokenDrop.algo.ts:597
	// assert(!this.isNfdExpired(userOfferedNFDAppId), 'NFD must not be expired')
	frame_dig 0 // userOfferedNFDAppId: uint64
	callsub isNfdExpired
	!

	// NFD must not be expired
	assert

	// contracts/TokenDrop.algo.ts:599
	// assert(
	//             rawBytes(AppID.fromUint64(userOfferedNFDAppId).globalState('i.owner.a') as Address) === rawBytes(claimer),
	//             "provided nfd for entry isn't owned by the claimer",
	//         )
	frame_dig 0 // userOfferedNFDAppId: uint64
	bytec 12 //  "i.owner.a"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(userOfferedNFDAppId).globalState('i.owner.a')
	assert
	frame_dig -2 // claimer: Address
	==

	// provided nfd for entry isn't owned by the claimer
	assert
	retsub

// isNfdAppIdValid(nfdAppId: uint64): boolean
//
// Checks if the given NFD App id is valid.  Using only the App id there's no validation against the name (ie: that nfd X is name Y)
// So it's assumed for the caller, the app id alone is fine.  The name is fetched from the specified app id and the two
// together are used for validity check call to the nfd registry.
//
// @param {uint64} nfdAppId - The NFD App id to verify.
//
// @returns {boolean} - Returns true if the NFD App id is valid, otherwise false.
isNfdAppIdValid:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:616
	// userOfferedNFDName = AppID.fromUint64(nfdAppId).globalState('i.name') as string
	frame_dig -1 // nfdAppId: uint64
	pushbytes 0x692e6e616d65 // "i.name"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppId).globalState('i.name')
	assert
	frame_bury 0 // userOfferedNFDName: string

	// contracts/TokenDrop.algo.ts:618
	// return sendMethodCall<[string, uint64], boolean>({
	//             applicationID: this.nfdRegistryAppId.value,
	//             name: 'isValidNfdAppId',
	//             methodArgs: [userOfferedNFDName, nfdAppId],
	//         })
	itxn_begin
	intc 6 //  appl
	itxn_field TypeEnum
	pushbytes 0x4be22fc6 // method "isValidNfdAppId(string,uint64)bool"
	itxn_field ApplicationArgs

	// contracts/TokenDrop.algo.ts:619
	// applicationID: this.nfdRegistryAppId.value
	bytec 11 //  "nfdRegistryId"
	app_global_get
	itxn_field ApplicationID

	// contracts/TokenDrop.algo.ts:621
	// methodArgs: [userOfferedNFDName, nfdAppId]
	frame_dig 0 // userOfferedNFDName: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	itxn_field ApplicationArgs
	frame_dig -1 // nfdAppId: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	intc 0 // 1
	-
	itxnas Logs
	extract 4 0
	intc 1 // 0
	getbit

	// set the subroutine return value
	frame_bury 0
	retsub

// isNfdPreV3(nfdAppId: uint64): boolean
isNfdPreV3:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:626
	// majVer = extract3(AppID.fromUint64(nfdAppId).globalState('i.ver') as bytes, 0, 2)
	frame_dig -1 // nfdAppId: uint64
	pushbytes 0x692e766572 // "i.ver"
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(nfdAppId).globalState('i.ver')
	assert
	extract 0 2
	frame_bury 0 // majVer: byte[]

	// contracts/TokenDrop.algo.ts:627
	// return majVer === '1.' || majVer === '2.'
	frame_dig 0 // majVer: byte[]
	pushbytes 0x312e // "1."
	==
	dup
	bnz *skip_or4
	frame_dig 0 // majVer: byte[]
	pushbytes 0x322e // "2."
	==
	||

*skip_or4:
	// set the subroutine return value
	frame_bury 0
	retsub

// isNfdForSale(nfdAppId: uint64): boolean
isNfdForSale:
	proto 1 1

	// contracts/TokenDrop.algo.ts:631
	// return this.safeGlobalIntGet(nfdAppId, 'i.sellamt') !== 0
	pushbytes 0x692e73656c6c616d74 // "i.sellamt"
	frame_dig -1 // nfdAppId: uint64
	callsub safeGlobalIntGet
	intc 1 // 0
	!=
	retsub

// isNfdExpired(nfdAppId: uint64): boolean
isNfdExpired:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x

	// contracts/TokenDrop.algo.ts:636
	// expTime = this.safeGlobalIntGet(nfdAppId, 'i.expirationTime')
	pushbytes 0x692e65787069726174696f6e54696d65 // "i.expirationTime"
	frame_dig -1 // nfdAppId: uint64
	callsub safeGlobalIntGet
	frame_bury 0 // expTime: uint64

	// *if17_condition
	// contracts/TokenDrop.algo.ts:637
	// expTime === 0
	frame_dig 0 // expTime: uint64
	intc 1 // 0
	==
	bz *if17_end

	// *if17_consequent
	// contracts/TokenDrop.algo.ts:639
	// return false
	intc 1 // 0
	b *isNfdExpired*return

*if17_end:
	// contracts/TokenDrop.algo.ts:641
	// return globals.latestTimestamp > expTime
	global LatestTimestamp
	frame_dig 0 // expTime: uint64
	>

*isNfdExpired*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// safeGlobalIntGet(appId: uint64, key: bytes): uint64
safeGlobalIntGet:
	proto 2 1

	// *if18_condition
	// contracts/TokenDrop.algo.ts:645
	// !AppID.fromUint64(appId).globalStateExists(key)
	frame_dig -1 // appId: uint64
	frame_dig -2 // key: bytes
	app_global_get_ex
	swap
	pop
	!
	bz *if18_end

	// *if18_consequent
	// contracts/TokenDrop.algo.ts:646
	// return 0
	intc 1 // 0
	retsub

*if18_end:
	// contracts/TokenDrop.algo.ts:648
	// return btoi(AppID.fromUint64(appId).globalState(key) as bytes)
	frame_dig -1 // appId: uint64
	frame_dig -2 // key: bytes
	app_global_get_ex

	// global state value does not exist: AppID.fromUint64(appId).globalState(key)
	assert
	btoi
	retsub

// isAddressInNFDCAAlgoList(nfdAppId: uint64, addrToFind: Address): boolean
//
// Checks if the specified address is present in an NFDs list of verified addresses.
// The NFD is assumed to have already been validated as official.
//
// @param {uint64} nfdAppId - The NFD application id.
// @param {Address} addrToFind - The address to find in the v.caAlgo.0.as property
// @return {boolean} - `true` if the address is present, `false` otherwise.
isAddressInNFDCAAlgoList:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	bytec 0 // 0x
	dupn 2

	// contracts/TokenDrop.algo.ts:660
	// sendAppCall({
	//             applicationID: AppID.fromUint64(nfdAppId),
	//             applicationArgs: ['read_property', 'v.caAlgo.0.as'],
	//         })
	itxn_begin
	intc 6 //  appl
	itxn_field TypeEnum

	// contracts/TokenDrop.algo.ts:661
	// applicationID: AppID.fromUint64(nfdAppId)
	frame_dig -1 // nfdAppId: uint64
	itxn_field ApplicationID

	// contracts/TokenDrop.algo.ts:662
	// applicationArgs: ['read_property', 'v.caAlgo.0.as']
	pushbytes 0x726561645f70726f7065727479 // "read_property"
	itxn_field ApplicationArgs
	pushbytes 0x762e6361416c676f2e302e6173 // "v.caAlgo.0.as"
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	intc 1 // 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// contracts/TokenDrop.algo.ts:664
	// caAlgoData = this.itxn.lastLog
	itxn LastLog
	frame_bury 0 // caAlgoData: byte[]

	// contracts/TokenDrop.algo.ts:665
	// for (let i = 0; i < caAlgoData.length; i += 32)
	intc 1 // 0
	frame_bury 1 // i: uint64

*for_0:
	// contracts/TokenDrop.algo.ts:665
	// i < caAlgoData.length
	frame_dig 1 // i: uint64
	frame_dig 0 // caAlgoData: byte[]
	len
	<
	bz *for_0_end

	// contracts/TokenDrop.algo.ts:666
	// addr = extract3(caAlgoData, i, 32)
	frame_dig 0 // caAlgoData: byte[]
	frame_dig 1 // i: uint64
	intc 3 // 32
	extract3
	frame_bury 2 // addr: byte[]

	// *if19_condition
	// contracts/TokenDrop.algo.ts:667
	// addr !== rawBytes(globals.zeroAddress) && addr === rawBytes(addrToFind)
	frame_dig 2 // addr: byte[]
	global ZeroAddress
	!=
	dup
	bz *skip_and0
	frame_dig 2 // addr: byte[]
	frame_dig -2 // addrToFind: Address
	==
	&&

*skip_and0:
	bz *if19_end

	// *if19_consequent
	// contracts/TokenDrop.algo.ts:668
	// return true
	intc 0 // 1
	b *isAddressInNFDCAAlgoList*return

*if19_end:

*for_0_continue:
	// contracts/TokenDrop.algo.ts:665
	// i += 32
	frame_dig 1 // i: uint64
	intc 3 // 32
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/TokenDrop.algo.ts:671
	// return false
	intc 1 // 0

*isAddressInNFDCAAlgoList*return:
	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 2
	retsub

// checkGatingInfo(tokenDropInfo: TokenDropConfig): void
checkGatingInfo:
	proto 1 0

	// contracts/TokenDrop.algo.ts:675
	// assert(
	//             tokenDropInfo.entryGatingType >= GATING_TYPE_NONE && tokenDropInfo.entryGatingType <= GATING_TYPE_CONST_MAX,
	//         )
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 24 1
	btoi
	intc 1 // 0
	>=
	dup
	bz *skip_and1
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 24 1
	btoi
	intc 9 // 7
	<=
	&&

*skip_and1:
	assert

	// *if20_condition
	// contracts/TokenDrop.algo.ts:679
	// tokenDropInfo.entryGatingType === GATING_TYPE_CREATED_BY_NFD_ADDRESSES ||
	//             tokenDropInfo.entryGatingType === GATING_TYPE_SEGMENT_OF_NFD
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 24 1
	btoi
	intc 8 // 3
	==
	dup
	bnz *skip_or5
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 24 1
	btoi
	intc 5 // 4
	==
	||

*skip_or5:
	bz *if20_end

	// *if20_consequent
	// contracts/TokenDrop.algo.ts:683
	// assert(
	//                 this.isNfdAppIdValid(tokenDropInfo.entryGatingAssets[0]),
	//                 'provided NFD App id for gating must be valid NFD',
	//             )
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 57 8
	btoi
	callsub isNfdAppIdValid

	// provided NFD App id for gating must be valid NFD
	assert

*if20_end:
	// *if21_condition
	// contracts/TokenDrop.algo.ts:688
	// tokenDropInfo.entryGatingType === GATING_TYPE_NFD_HOLDING_AGE
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 24 1
	btoi
	intc 9 // 7
	==
	bz *if21_end

	// *if21_consequent
	// contracts/TokenDrop.algo.ts:689
	// assert(tokenDropInfo.gatingAssetMinBalance > 0, 'asset min balance - used as nfd holding age - must be >0')
	frame_dig -1 // tokenDropInfo: TokenDropConfig
	extract 89 8
	btoi
	intc 1 // 0
	>

	// asset min balance - used as nfd holding age - must be >0
	assert

*if21_end:
	retsub

// costForBoxStorage(totalNumBytes: uint64): uint64
costForBoxStorage:
	proto 1 1

	// contracts/TokenDrop.algo.ts:697
	// return SCBOX_PERBOX + totalNumBytes * SCBOX_PERBYTE
	pushint 2500
	frame_dig -1 // totalNumBytes: uint64
	pushint 400
	*
	+
	retsub

*create_NoOp:
	pushbytes 0x600a2a67 // method "createApplication(uint64,address)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	pushbytes 0x04e9cd45 // method "changeMaintainer(address)void"
	pushbytes 0x644611f3 // method "changeFees(uint64,uint64)void"
	pushbytes 0xdc2a1647 // method "optinAsset(pay,uint64)void"
	pushbytes 0xad15c219 // method "getDropCreateCost()uint64"
	pushbytes 0x133e6d6c // method "getPerClaimerMbrCost()uint64"
	pushbytes 0x72990150 // method "getPerClaimerFee()uint64"
	pushbytes 0x76710ad4 // method "getDropInfo(uint64)(uint64,address,uint64,uint64,uint64,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))"
	pushbytes 0xfceed605 // method "createDrop(pay,axfer,(uint64,uint64,uint64,uint8,address,uint64[4],uint64))uint64"
	pushbytes 0x348b286a // method "cancelDrop(uint64)void"
	pushbytes 0xe6db5e0d // method "claimDrop(pay,uint64,uint64)void"
	pushbytes 0x3609129f // method "claimClaimerBoxCost(uint64,address,address)void"
	pushbytes 0x37eafce4 // method "cleanupDrop(uint64)void"
	txna ApplicationArgs 0
	match *abi_route_changeMaintainer *abi_route_changeFees *abi_route_optinAsset *abi_route_getDropCreateCost *abi_route_getPerClaimerMbrCost *abi_route_getPerClaimerFee *abi_route_getDropInfo *abi_route_createDrop *abi_route_cancelDrop *abi_route_claimDrop *abi_route_claimClaimerBoxCost *abi_route_cleanupDrop

	// this contract does not implement the given ABI method for call NoOp
	err

*call_UpdateApplication:
	pushbytes 0x46f76533 // method "updateApplication()void"
	txna ApplicationArgs 0
	match *abi_route_updateApplication

	// this contract does not implement the given ABI method for call UpdateApplication
	err